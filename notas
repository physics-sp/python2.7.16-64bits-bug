

Python > ceval.c -> PyEval_EvalFrameEx


opcode.opname[0x64] == 'LOAD_CONST':



linea 3219 en decomp de ghidra
la func arranca en 001f08d0

LOAD_CONST:
001f5988 en codigo (Creo)

        001f5988 4d 8b 64        MOV        R12,qword ptr [R14 + RDX*0x8 + 0x18]
                 d6 18
        001f598d 4d 8d 73 08     LEA        R14,[R11 + 0x8]
        001f5991 49 83 04        ADD        qword ptr [R12],0x1
                 24 01
        001f5996 4d 89 23        MOV        qword ptr [R11],R12
        001f5999 8b 05 19        MOV        EAX,dword ptr [DAT_004a25b8]                     = ??
                 cc 2a 00
        001f599f 4d 89 cb        MOV        R11,R9
        001f59a2 4c 2b 5c        SUB        R11,qword ptr [RSP + 0x18]
                 24 18
        001f59a7 89 c1           MOV        ECX,EAX





        https://docs.python.org/2.7/library/dis.html

EXTENDED_ARG(ext)

    Prefixes any opcode which has an argument too big to fit into the default two bytes. ext holds two additional bytes which, taken together with the subsequent opcode’s argument, comprise a four-byte argument, ext being the two most-significant bytes.




Ajustar:
1) tamaño de padding en first_indirection
2) tamaño de padding en fake_object
3) orden en la resta en el calculo de offset
4) cantidad de EXTENDED_ARG en bytecode


Python > abstract.c -> PyObject_Call



            
  
  pcVar1 = *(code **)(*(long *)(lParm1 + 8) + 0x80);
  if (pcVar1 == (code *)0x0) {
    PyErr_Format(PyExc_TypeError,"\'%.200s\' object is not callable",
                 *(undefined8 *)(*(long *)(lParm1 + 8) + 0x18));
    lVar3 = 0;
  }
  else {
    iVar4 = *(int *)(_PyThreadState_Current + 0x18) + 1;
    *(int *)(_PyThreadState_Current + 0x18) = iVar4;
    if (_Py_CheckRecursionLimit < iVar4) {
      iVar4 = _Py_CheckRecursiveCall(" while calling a Python object");
      if (iVar4 != 0) {
        return 0;
      }
      lVar3 = (*pcVar1)(lParm1,uParm2);



        001d26b8 48 8b 47 08     MOV        RAX,qword ptr [RDI + 0x8]
        001d26bc 48 8b 98        MOV        RBX,qword ptr [0x80 + RAX]
                 80 00 00 00
        .....
        001d26f1 ff d3           CALL       RBX

1) tamaño de padding de first_indirection es 0x80
2) tamaño de padding de fake_object es 0x8



http://unpyc.sourceforge.net/Opcodes.html -> EXTENDED_ARG


  https://stackoverflow.com/questions/25083861/what-do-the-zeros-in-python-function-bytecode-mean
With 2 bytes you can give any bytecode an argument value between 0 and 65535, for bytecodes than need more, you can prefix the bytecode with the EXTENDED_ARG bytecode, adding 2 more bytes for a value between 0 and 4294967295. In theory you could use EXTENDED_ARG multiple times, but the CPython interpreter uses int for the oparg variable and is thus for practical purposes limited to 4-byte values.

